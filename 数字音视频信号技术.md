# 数字音视频信号技术

## 一、视频图像编码

### 要点

+ 图像视频压缩的概述和目的
+ 数字视频色彩空间
  + **YUV** 和其采样

+ 彩色电视制式
+ 熵编码
  + **编码效率**
  + **哈夫曼编码**
  + **算术编码**

+ 预测编码
  + **DPCM 概述**
  + **MV 二维对数搜索算法**

+ 变换编码
  + **DCT 的性质**

+ 现代视频格式
+ JPEG
+ MPEG

### 1.1 图像视频编码概述

数字视频信号是在采集过程中，通过对模拟信号进行采样和量化后获得的。未经过压缩的初始视频信号所需要的存储空间为：
$$
视频比特数=采样频率\times量化位数\times视频宽\times视频高\times帧率\times时间
$$
没有压缩过的原始视频体积一般较大，不符合传输要求，因此，要利用信号本身的一些对原始信号进行压缩和编码。现代网络视频编码不仅要求能够减少视频体积，还要求视频能够便于在网络中按照特定协议进行传输，并且能够被快速解析。

### 1.2 信号冗余

一般的，信号在频率域和时域上存在一些冗余。对于视频和图像信号，一般有：

+ 空间冗余：图像内容各部分有很大相似性，如蓝天背景；
+ 时间冗余：相邻的两帧图像间部分或全部区域相似，或者完全一致，如一段静物景象；
+ 结构冗余：图像部分符合特定模式重复出现，如纹理；
+ 编码冗余：也称符号冗余，图像编码中存在信息冗余，可以用香农熵理论进行解释；
+ 视觉冗余：人眼对图像的感知是非均匀和非线性的，对图像各部分的敏感度不同，一些图像细节不需要较高分辨率；
+ 知识冗余：在一些特定场合中，视频信号中的信息与某些先验知识相关，如人的五官相对位置，可以对这些知识进行建模。

### 1.3 通用视频中间格式

视频信号传输技术最早被使用在电视产业中，为了保证工业上的标准性，业界定制了一些被称为通用中间格式（Common Intermediate Format，CIF）的格式标准。这些标准规定了视频的大小格式，而不是编码格式。

在传统数字电视系统中，国际电报电话咨询委员会（CCITT）规定了：

+ SQCIF：128x96
+ QCIF：176x144
+ CIF：352x288
+ 4CIF：720x576

现代通用视频标准有：

+ SD：标清，480p，720x576
+ HD：高清，720p，1280x720
+ FHD：全高清，1080p，1920x1080
+ UHD：超高清，4K，3840x2160
+ FUHD：全超高清，8K，7680x4320

### 1.4 彩色电视制式

传统电视系统中有三种常用的彩色电视制式：NTSC，PAL，SECAM 。

#### 隔行扫描

和现代网络视频不同，传统电视信号大多使用**隔行扫描（interlaced scanning）**技术。电视信号在输出时，首先输出所有奇数行的信号，再输出偶数行信号，人眼难以察觉到信号输出间的延迟，因此视频图像可以更快的显示在屏幕上。一般的，使用隔行扫描输出的视频格式会在尾部加上字母 i ，如 1080i 表示隔行扫描的全高清视频。

#### NTSC

NTSC(National Television Systems Committee)彩色电视制是 1952 年美国国家电视标准委员会定义的彩色电视广播标准，称为正交平衡调幅制。NTSC 的特点有：

+ 每帧 525 行，帧率 29.97 fps ；
+ 电视纵横比 4:3，电影 3:2 ，高清电视 16:9 ；
+ 隔行扫描；
+ 颜色模型使用 YIQ 。

#### PAL

由于 NTSC 存在相位敏感造成彩色失真的缺点，联邦德国在 1962 年制定了 PAL(Phase-Alternative Line) 电视标准，这也是我国正在使用的标准电视制式。PAL 的特点有：

+ 每帧 625 行，帧率 25 fps；
+ 纵横比 4:3；
+ 隔行扫描；
+ 颜色模型使用 YUV 。

####  SECAM

SECAM 是由法国、俄罗斯和一些东欧国家使用的电视制式，图像格式为 4:3，625 线，50 Hz，6 MHz 电视信号带宽，总带宽8MHz。

### 1.5 YUV 颜色模型

在视频编码中，最常使用的颜色模型是 Y'CrCb 模型，工业上一般称为 **YUV 颜色模型**。该模型采用亮度 + 色度的方式表示像素块颜色，其中 **Y 分量**表示亮度，**U 分量（Cb）**表示蓝色投影，**V 分量（Cr）**表示红色投影。

由于人眼对亮度信息的敏感度要高于色度信息，利用该视觉冗余特性，YUV 适当降低了色度分量的采样率，因此减少了传输带宽并不会对图像质量产生太大影响。YUV 主要有四种采样格式：4:4:4，4:2:2，4:2:0，4:1:1 。

#### 4:4:4 采样

以 PAL 制式为例，4:4:4 方法按以下方式采样：

![4:4:4](.数字音视频信号技术-assets/image-20220322171539012.png)

即对于每个像素，都进行 YUV 分量的采样。

#### 4:2:2 采样

以 PAL 制式为例，4:2:2 方法按以下方式采样：

![4:2:2](.数字音视频信号技术-assets/image-20220322171728615.png)

即在每行中，间隔两个像素进行一次 UV 采样（取两个像素的 UV 平均值），而对每个像素都进行 Y 采样。

#### 4:1:1 采样

以 PAL 制式为例，4:1:1 方法按以下方式采样：

![4:1:1](.数字音视频信号技术-assets/image-20220322171835334.png)

即在每行中，间隔四个像素进行一次 UV 采样（取四个像素的 UV 平均值），而对每个像素都进行 Y 采样。

#### 4:2:0 采样

以 PAL 制式为例，4:2:0 方法按以下方式采样：

![4:2:0](.数字音视频信号技术-assets/image-20220322172308277.png)

和 4:1:1 不同，4:2:0 对 UV 分量的采样是跨行的，即取一个 4x4 像素空间的 UV 平均值。

### 1.6 PCM 脉冲编码调制

**脉冲编码调制（Pulse Code Modulation，PCM）**是数字通信技术的基础，用于将模拟信号转换为数字信号，最早于 1937 年由 A·弗里斯提出，在 20 世纪 70 年代迅速发展。

PCM 将连续模拟信号转换为离散二进制数字信号，经历三个过程：取样、量化和编码。

#### 取样

**取样**也称采样或抽样，通过对模拟信号进行周期性扫描（称为**采样频率**），把时间上连续的信号变成时间上离散的信号，采样过程需要遵守奈奎斯特采样定理：信号的采样频率必须超过最高信号频率的 2 倍，否则将产生信号混叠并导致失真。

#### 量化

量化即是将采样结果离散处理，将一段连续区间内的所有模拟信号频率归于同一个离散值，一般使用二进制表示量化结果。量化结果和采样结果间的误差称为量化误差，在信号接收端将表现为噪声。为了减少噪声数量，一般采用**非均匀量化**（对不同能量区间进行拉伸或收缩）方法。非均匀量化的优点是可以减少甚至放弃出现概率小的信号范围的量化位数，分配更多的量化位数给出现概率更大的信号范围。

#### 编码

**编码**是使用有特定格式的二进制数据表示一个连续模拟信号离散值的过程，由于量化和编码通常是同时进行的，编码也被称为模数转换（A/D）。

### 1.7 图像编码

和其他通信技术类似，视频图像通信技术也有通用的描述模型。对于视频图像信号，该模型各步骤可以概括和解释为：

1. 信源采样：获取图像视频信号，将模拟信号转换为数字信号；
2. 信号预处理：使用数字图像处理技术处理未压缩的像素位图；
3. **信源编码**：对图像信号内容进行编码，目的是减小图像信号冗余度以**降低传输带宽**，如 JPEG 编码能够减少图片大小；
4. **信道编码**：对信号各部分按照一定通信协议进行封装，目的是使图像视频信号**更适合在本地或网络环境中进行传输**，如 WebRTC 是一种适用于实时视频通信的因特网应用层协议；
5. 调制，传输和解调：将数字信号转化为模拟信号后在信道中传输，并在接收端解调为数字信号；
6. **信道解码**：信道编码逆过程；
7. **信源解码**：信源解码逆过程；
8. **信源解析**：将解码后的图像视频渲染到设备。

#### 图像压缩编码类型

图像压缩编码分为有损压缩和无损压缩两类：

+ **无损压缩**：压缩和解压不会损伤原始信号，相比有损压缩压缩率较低，常见的有 TIF、BMP、GIF、PNG 格式等，一般采用预测和熵编码；
+ **有损压缩**：压缩过程舍弃了部分原始信号，比无损压缩效率更高，一般采用变换和量化编码方法。

#### 熵编码

熵，即**香农熵（Shannon Entropy）**，是指信源中所含**平均信息量**进行无失真压缩编码的理论极限。熵编码是一类无损编码。

##### 编码效率评估

**信息量**描述的是信源中各个符号出现的不确定性。对于每个出现概率为 p(x~i~) 的符号 x~i~，其信息量 I(x~i~) 计算公式为：
$$
I(x_i)=-\log_2{p(x_i)}
$$
**信息熵** H(X) 则是信源中各个符号不确定度的数学期望，单位比特/符号，表达的是信源中每个符号的平均信息量：
$$
H(X)=\sum_{i=1}{p(x_i)I(x_i)}=-\sum_{i=1}{p(x_i)\log_2p(x_i)}
$$

由于信息熵表示信源中符号平均信息量，可以用其计算编码后的存储空间效率。首先需要计算**平均码长** $\overline{K}$：
$$
\overline{K}=\sum_{i=1}{p(x_i)K_i}
$$
**编码效率 η** 则为：
$$
η=H(x)/\overline{K}
$$

##### 游程编码

**游程编码**，也称**行程编码（Run Length Encoding，RLE)**，是一种最简单的熵编码。游程编码将二维图像转为一维描述，使用符号 + 计数的方式描述一串信号，如`aaaa bbb cc d eeeee fffffff`可以描述为`4a3b2c1d5e7f`。

游程编码特别适合二值图像的压缩和其他信源中符号数量较少的信号压缩，不适合信源符号较复杂的信号压缩。由于其简单有效的特点，游程编码经常与其他编码方式混合使用，如 JPEG 就使用了游程编码进行维度转换和压缩。

##### 哈夫曼编码

**哈夫曼编码（Huffman Coding）**过去被称作最优编码方法，依赖于对信源符号出现概率的预先统计结果。哈夫曼编码是一种可变长的前缀编码，使用一棵哈夫曼树抽象表示编码过程，将各符号转换为二进制比特串。符号出现概率越高，其串长久越短。

以信号`aaaa bbb cc d eeeee fffffff`为例，首先统计各符号出现概率：

| 符号 | 概率 |
| :--: | :--: |
|  a   | 4/22 |
|  b   | 3/22 |
|  c   | 2/22 |
|  d   | 1/22 |
|  e   | 5/22 |
|  f   | 7/22 |

然后按算法步骤形成一棵带权哈夫曼二叉树：

1. 将各符号视为一棵带权的只有一个节点的树，其出现概率为根节点权重；
2. 选择两个权重最小的树作为左右子树形成一棵新树，新的根节点权重为左右子树权重和。可以预先规定较大或较小权重为左树或右树，以 0 或 1 编码，下方例子中大树赋 1 为左树；
3. 重复步骤 2，直到最后只剩一棵二叉树，这棵树就为哈夫曼树，其根节点权值为 1；

根据得到的哈夫曼树，自上而下地根据遍历路径生成哈夫曼编码表：

| 符号 | 编码 |
| :--: | :--: |
|  a   |  00  |
|  b   | 101  |
|  c   | 1001 |
|  d   | 1000 |
|  e   |  01  |
|  f   |  11  |

根据哈夫曼编码表，生成编码后的二进制信号：`1010101010001001001000100010000111111111101010101010101`。可见哈夫曼编码结果是一种二值信号，因此特别适合再次**使用游程编码压缩**。

要对哈夫曼编码进行解码，只需查阅编码表并进行前缀匹配。

##### 算术编码

**算术编码**是一种巧妙的熵编码方法，相比哈夫曼编码，可以不用预先建立概率模型（统计详细的符号出现个数）。算术编码的结果是一串表示浮点数的二进制小数，其**小数位数**等于信源符号长度。

###### 编码

算术编码需要首先获得对信源符号出现概率的初步统计，该统计可以是不准确的，不会影响编解码正确性，但是会影响编码效率。以字符串`ARBER`为例进行编码，首先建立区间表（出现次数可选）：

| Symbol | Times | *P*  |
| ------ | ----- | ---- |
| A      | 1     | 0.2  |
| B      | 1     | 0.2  |
| E      | 1     | 0.2  |
| R      | 2     | 0.4  |

算术编码本质是在进行一系列区间转换过程，首先将这些字符的区间在 [0，1) 上按概率大小分配区间：

![算术编码](.数字音视频信号技术-assets/算术编码1.png)

形成区间表：

| Symbol | L    | H    |
| ------ | ---- | ---- |
| A      | 0    | 0.2  |
| B      | 0.2  | 0.4  |
| E      | 0.4  | 0.6  |
| R      | 0.6  | 1    |

`L`和`H`将在之后的计算中被称为符号的**相对区间**，而区间转换会不断缩小信号的**绝对区间**上下限`high`和`low`，使用公式：
$$
low=low+（high−low）∗L\\
high=low+（high−low）∗H
$$
刚开始信号绝对区间是 [0，1)，即：
$$
low = 0\\\ high = 1
$$
第一个字符 A 的相对区间是 [0，0.2)，则 *L* = 0，*H* = 0.2：
$$
low=low+（high−low）∗L=0\\
high=low+（high−low）∗H=0.2
$$


第二个字符 R 的相对区间是 [0.6，1)，则 *L* = 0.6，*H* = 1：
$$
low=low+（high−low）∗L=0.12\\
high=low+（high−low）∗H=0.2
$$


第三个字符 B 的相对区间是 [0.2，0.4)，则 *L* = 0.2，*H* = 0.4：
$$
low=low+（high−low）∗L=0.136\\
  high=low+（high−low）∗H=0.152
$$
以此类推，最后结果区间为 [0.14432, 0.1456)，取其中一个小数作为编码结果（为避免离散浮点数运算精度问题，尽量远离边界），本例中取小数`0.14435`。

详细过程：

```json
{ low: 0, high: 0.2 }
{ low: 0.12, high: 0.2 }
{ low: 0.136, high: 0.152 }
{ low: 0.1424, high: 0.1456 }
{ low: 0.14432, high: 0.1456 }
```

###### 解码

解码小数是复原绝对区间到最终编码后的绝对区间（ [ 0, 1 ) 到 [ 0.14432, 0.1456 ) ），并观察编码小数所处区间范围和符号相对区间的绝对值是否匹配的过程。在程序运行过程中，可以将区间表视为可写表，解码小数是一个不断更新区间表的过程，每更新一次区间表就可输出一个解码字符，解码字符数量即是小数的位数。每次更新，都是将表项的相对区间值转化为绝对区间值，因此有公式：
$$
L=上一表项的L（对于第一项而言为low）\\
H=L+(high-low)*p
$$
接下来的解码过程需要参阅之前的区间表，过程为：

1. 每轮迭代从第一表项开始；
2. 如果小数不处于当前表项区间 [ L, H )，更新下一表项相对区间；
3. 如果小数处于当前表项区间，输出对应字符为解码结果，并以该表项相对区间作下一次迭代的绝对区间，开始下一轮迭代；
4. 迭代，直到输出字符数量与小数位数相等。

详细过程：

```json
// 初始绝对区间为 0, 1
Char { symbol: 'A', p: 0.2, L: 0, H: 0.2 }		
// 更新绝对区间为 0, 0.2，输出字符 A
Char { symbol: 'A', p: 0.2, L: 0, H: 0.04 }
Char { symbol: 'B', p: 0.2, L: 0.04, H: 0.08 }
Char { symbol: 'E', p: 0.2, L: 0.08, H: 0.12 }
Char { symbol: 'R', p: 0.4, L: 0.12, H: 0.2 }		
// 更新绝对区间为 0.12, 0.2，输出字符 R
Char { symbol: 'A', p: 0.2, L: 0.12, H: 0.136 }
Char { symbol: 'B', p: 0.2, L: 0.136, H: 0.152 }		
// 更新绝对区间为 0.136, 0.152，输出字符 B
Char { symbol: 'A', p: 0.2, L: 0.136, H: 0.1392 }
Char { symbol: 'B', p: 0.2, L: 0.1392, H: 0.1424 }
Char { symbol: 'E', p: 0.2, L: 0.1424, H: 0.1456 }		
// 更新绝对区间为 0.1424, 0.1456，输出字符 E
Char { symbol: 'A', p: 0.2, L: 0.1424, H: 0.14304 }
Char { symbol: 'B', p: 0.2, L: 0.14304, H: 0.14368 }
Char { symbol: 'E', p: 0.2, L: 0.14368, H: 0.14432 }
Char { symbol: 'R', p: 0.4, L: 0.14432, H: 0.1456 }		
// 更新绝对区间为 0.14432, 0.1456，输出字符 R
// 字符位数等于小数位数，运算结束，结果 ARBER
```

#### 轮廓编码

由于任意图像都可以分离出前景和背景部分，并被进一步分割为多个区域，因此可以采用对区域进行编码的方式减小信号体积。**轮廓编码（contour coding）**主要使用了对区域轮廓进行编码的方法。

轮廓编码主要需要解决两个问题：

1. 如何跟踪灰度轮廓；
2. 如何选取轮廓初始点；

解决问题的算法被称为跟踪 T（Trace）算法和初始点选取 IP（Initial Point）算法。

#### 预测编码

**预测编码**包括**帧内编码（Intra Coding）**和**帧间编码（Inter Coding）**，前者利用空间冗余进行压缩，用于图像编码，后者利用时间冗余进行压缩，用于视频编码。在预测编码中，一般不传递图像信号本身，而是对图像实际信号和其预测信号间的**差值**进行编码和传输。

##### DPCM 差分脉冲编码调制

**差分脉冲编码调制（Differential Pulse Code Modulation，DPCM）**是对预测值和实际值差值进行数模转换的编码方式，属于帧内预测。该编码方式只取一个原始信号实际值，并计算其预测值与两者的差值，之后的运算都是预测值与预测值做差。

DPCM 的优点是算法简单，易于硬件实现，但是具有噪声敏感的缺点，并会引发误差扩散（前一预测出错将影响之后所有的预测），此外 DPCM 的压缩率也较低。

#### 变换编码

**变换编码**是另一种减少信号冗余度的技术手段，提高变换编码压缩率的关键是要找到一个恰到好处的**正交变换矩阵**（也称系数矩阵），并且变换过程必须**可逆**。对于图像信号，变换编码一般先将图像分为多个小块，然后对每个小块执行变换。常见的正交变换方式有：

+ 离散傅里叶变换（DFT）：傅里叶变换在众多研究领域均有使用。在信号处理技术中，傅里叶变换一般用于时域到频域的变换与逆变换，变换后的信号往往只需要更小的体积便可存储，并且部分噪声将会和有效信息区域分离，因此一般会用于**图像去噪**。DFT 的优化版本称为快速傅里叶变换（FFT）；
+ 离散小波变换（DWT）：离散小波变换具有可以保留图像空间特点的性质；
+ 沃尔什·哈达玛变换（Walsh-Hadamard，WHT）：WHT 是一种运算过程较为简单的正交变换，其系数矩阵在使用时主要进行加性运算而不是乘性运算；
+ 卡洛南-洛伊变换（K-L，KLT）：KLT 是已经得到证明的在均方误差最小准则下失真最小的变换方式，因此被称为**最佳变换**；由于 KLT 的系数矩阵是由信源图像本身的协方差矩阵的特征矢量组成的，对于每幅图像都必须先计算出其变换系数矩阵，计算过于复杂，在生产环境中很少会用到该方法；
+ **离散余弦变换（DCT）**

##### 变换编码基本过程

变换编码使用的基本过程有：

1. 选择变换方式：即选择一个合适的系数矩阵，实践中几乎都使用 DCT 的系数矩阵；
2. 选择变换方案：在变换前对图像进行预处理，如分块（核滤波）；
3. 指定量化规则：使用均匀量化或非均匀量化，一般图像信号使用均匀量化；
4. 选择编码方式：对量化结果编码，如游程编码和哈夫曼编码。

##### 离散余弦变换 DCT

在对自然图像进行编码时，**离散余弦变换**最接近 KFT，因此被称为**准最佳变换**，DCT 变换的系数矩阵与信源图像本身无关，计算复杂度较低，被广泛用于图像压缩技术中。DCT 的优化版称为快速离散余弦变换 FDCT。

经过变换编码处理后的图像信号，其能量将集中在少数坐标轴中，符合“对信号中出现概率为 0 或很小的位置分配尽量少或不分配量化因子，对信号出现概率高的位置，分配多的量化因子”的**压缩策略**。因为在编码中会放弃部分信号，DCT 压缩属于一种**有损压缩**。在多种变换中，DCT 是除 KLT 以外能量压缩效率最佳的，编码后的能量将集中于图片的**左上角**：

![DFT 和 DCT](.数字音视频信号技术-assets/image-20220328222655635.png)

离散余弦变换可以实现为二维图像滤波，系数矩阵即是滤波器核，主要进行乘性运算（对于模拟图像，则先乘以量化矩阵变换为离散数字图像）：

+ 编码：原图像对应像素乘以核（系数矩阵）对应位置值并取整，得到压缩图像；
+ 解码：压缩图像对应像素除以核对应位置值并取整，得到原图像；

![左：原始图像	右：压缩后解压图像](.数字音视频信号技术-assets/image-20220328225136456.png)

下列图像比较清晰的展示了 DCT 后图像的能量集中特征：

+ 保留变化后图像左上角 1x1 像素区域的能量：

![保留左上角能量](.数字音视频信号技术-assets/image-20220328231447912.png)

+ 去掉左上角 1x1 区域的能量：

![去除左上角能量](.数字音视频信号技术-assets/image-20220328231643629.png)

+ 保留第一行水平能量：

![保留第一行水平能量](.数字音视频信号技术-assets/image-20220328231721755.png)

+ 保留第一列垂直能量：

![保留第一列垂直能量](.数字音视频信号技术-assets/image-20220328231740024.png)

+ 保留对角能量：

![image-20220328231830046](.数字音视频信号技术-assets/image-20220328231830046.png)

+ 保留 2x2 和 3x3 区域的能量：

![2x2](.数字音视频信号技术-assets/image-20220328231943254.png)

![3x3](.数字音视频信号技术-assets/image-20220328232017181.png)

#### 实例研究：JPEG

### 1.8 视频编码

视频编码即是对一组连续图像序列进行编码，因此是对图像编码技术的组合运用。由于视频还拥有时间维度，因此可以通过帧间预测编码减少时间冗余进行压缩。

#### 运动补偿预测编码

##### MV 二维对数搜索算法

#### 实例研究：MPEG-4 H264

## 二、音频编码
